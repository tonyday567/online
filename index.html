<meta charset="utf-8"> <link rel="stylesheet" href="https://tonyday567.github.io/other/lhs.css">
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<h1 id="online-build-status"><a href="https://github.com/tonyday567/online">online</a> <a href="https://travis-ci.org/tonyday567/online"><img src="https://travis-ci.org/tonyday567/online.png" alt="Build Status" /></a></h1>
<p>online turns a statistic (a summary or fold of data) into an online algorithm.</p>
<h1 id="derivation">derivation</h1>
<p>Imagine a data stream, like an ordered indexed container or a time-series of measurements. An exponential moving average can be calculated as a repeated iteration over a stream of xs:</p>
<p><span class="math display">\[ ema_t = ema_{t-1} * 0.9 + x_t * 0.1 \]</span></p>
<p>The 0.1 is akin to the learning rate in machine learning, or 0.9 can be thought of as a decaying or a rate of forgetting. An exponential moving average learns about what the value of x has been lately, where lately is, on average, about 1/0.1 = 10 x's ago. All very neat.</p>
<p>The first bit of neat is speed. There's 2 times and a plus. The next is space: an ema is representing the recent xs in a size as big as a single x. Compare that with a simple moving average where you have to keep the history of the last n xs around to keep up (just try it).</p>
<p>It's so neat, it's probably a viable monoidal category all by itself.</p>
<h1 id="online">online</h1>
<p>Haskell allows us to abstract the compound ideas in an ema and create polymorphic routines over a wide variety of statistics, so that they all retain these properties of speed, space and rigour.</p>
<pre><code>av xs = L.fold (online identity (.* 0.9)) xs
-- av [0..10] == 6.030559401413827
-- av [0..100] == 91.00241448887785</code></pre>
<p><code>online identity (.* 0.9)</code> is how you express an ema with a decay rate of 0.9.</p>
<p>Here's an average of recent values for the grey line, for r=0.9 and r=0.99.</p>
<div class="figure">
<img src="other/av.svg" />

</div>
<p>online works for any statistic. Here's the construction of standard deviation using applicative style:</p>
<pre><code>std :: Double -&gt; L.Fold Double Double
std r = (\s ss -&gt; sqrt (ss - s**2)) &lt;$&gt; ma r &lt;*&gt; sqma r
  where
    ma r = online identity (.*r)
    sqma r = online (**2) (.*r)</code></pre>
<p>And the results over our fake data:</p>
<div class="figure">
<img src="other/std.svg" />

</div>
