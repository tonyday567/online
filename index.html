<p><meta charset="utf-8"> <link rel="stylesheet" href="other/lhs.css"></p>
<h1 id="online-build-status"><a href="https://tonyday567.github.io/readme-lhs/index.html">online</a> <a href="https://travis-ci.org/tonyday567/online"><img src="https://travis-ci.org/tonyday567/online.png" alt="Build Status" /></a></h1>
<p>Exploring the design space of online algorithms, charting, statistics and haskell.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Protolude</span> <span class="kw">hiding</span> ((%))
<span class="kw">import </span><span class="dt">Control.Monad.Primitive</span> (unsafeInlineIO)</code></pre></div>
<h2 id="online-library">online library</h2>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Online</span>
<span class="kw">import qualified</span> <span class="dt">Control.Foldl</span> <span class="kw">as</span> <span class="dt">L</span></code></pre></div>
<p>tl;dr</p>
<p>online turns a statistic (a summary or fold of data) into an online algorithm.</p>
<h2 id="motivation-a-simple-moving-average">motivation: a simple moving average</h2>
<p>To start somewhere, let's deconstruct the calculation of a simple moving average. Here's an average:</p>
<pre><code>av xs = (sum xs/length xs)
-- av [0..10] == 5.0</code></pre>
<p>Imagine that there is a data stream, arriving in an sequence (an ordering from first to last). As the data values arrive, a state variable is updated which is the moving average of the last 3 values (ma3). To calculate ma3, the values so far would be multiplied by the following weights, summed, and divided by 3.</p>
<p>When 6 values have been consumed so far, the ma3 is:</p>
<pre><code>sum(xs * [0 0 0 1 1 1])/3</code></pre>
<p>The next value streams in, and the ma3 calculation weights now looks like this:</p>
<pre><code>0 0 0 0 1 1 1</code></pre>
<p>The difference between these weights and the previous weights is:</p>
<pre><code>w = [0 0 0 -1 0 0 1]</code></pre>
<p>So that the ma3 can be calculated as <span class="math inline"><em>m</em><em>a</em>3<sub><em>t</em></sub> = <em>m</em><em>a</em>3<sub><em>t</em> − 1</sub> + ∑(<em>w</em> * <em>x</em><em>s</em>)/3</span></p>
<h2 id="a-better-moving-average">a better moving average</h2>
<p>There are other weighting schemes, and a better one than the simple moving average is the exponential moving average, where the weights look like this:</p>
<pre><code>0.1 * [... (0.9^2) (0.9^1) (0.9^0) _]

0.1 * [... (0.9^3) (0.9^2) (0.9^1) 1]</code></pre>
<p>So that the difference is:</p>
<pre><code>0.1 * [... (-0.1 * 0.9^2) (-0.1 * 0.9^1) (-0.1 * 0.9^0) 1]</code></pre>
<p>And, as it happens, <span class="math inline"><em>e</em><em>m</em><em>a</em><sub><em>t</em></sub> = 0.9 * <em>e</em><em>m</em><em>a</em><sub><em>t</em> − 1</sub> + 0.1 * <em>x</em><sub><em>t</em></sub></span></p>
<p>This state variable (or statistic) is quite compact (one state variable being the current ma) compared with the simple moving average where the last n values need to be remembered in order to drop the nth oldest each update. This also makes it blaxingly fast compared to the simple average update.</p>
<p>More generally, the baseline narrative of an online moving average - what have the values averaged lately - tends towards preferring the exponential version as:</p>
<ul class="incremental">
<li>very old values are almost forgotten ie not be influencing the current moving average much at all, compared with the simple moving average where past values go from having no effect to a lot at an arbitrary point in the history.</li>
<li>newer values should hold more weight than older ones; weights are monotonicaly decreasing from latest to oldest value.</li>
</ul>
<h2 id="online">online</h2>
<p><code>online</code> reifies this pattern into the foldl library api:</p>
<pre><code>av xs = L.fold (online id (*0.9)) xs
-- av [0..10] == 6.030559401413827
-- av [0..100] == 91.00241448887785</code></pre>
<p>And provides an intuitive representation of how big recent numbers have been at the end of a [0..100] data stream: 91ish rather than 50 when comparing the lifetime average.</p>
<p>online exposes:</p>
<ul class="incremental">
<li>a decay function governing the rate at which the statistic decays.</li>
<li>a stat function, that is the statistic to be computed.</li>
</ul>
<h2 id="decay">decay</h2>
<p>The decay function <code>(*r)</code> can be widely interpreted:</p>
<ul class="incremental">
<li>a decay function equal to <code>id</code> provides lifetime statistical calculations ie no forgetting.</li>
<li>a decay function of <code>const 0</code> (or <code>(*0)</code>) provides the latest value ie always forget.</li>
<li>in physical systems, an exponential-weighted moving average where the center-of-mass is x would be isomorphic to a decay function of (*(1-1/x)).</li>
<li>where the data represents time series, the center-of-mass is often referred to as duration. The duration of (*0.99) is 100.</li>
<li>in bayesian methods, a learning rate of x is often equivalent to a statistic being decayed or forgotten by (*(1-x))</li>
</ul>
<h2 id="stat">stat</h2>
<p>stat is a premap function that is the statistic of interest:</p>
<pre><code>av = online id id</code></pre>
<p>is a classical average over the whole sample with no forgetting.</p>
<pre><code>ma x = online id (*0.9)</code></pre>
<p>is a moving average with a decay rate of 0.9.</p>
<pre><code>sqav = online (*2) id</code></pre>
<p>is a lifetime squared average.</p>
<p>foldl Fold's are applicative functors, so:</p>
<pre><code>std = (\s ss -&gt; sqrt (ss - s**2)) &lt;$&gt; av &lt;*&gt; sqav</code></pre>
<p>is the standard deviation.</p>
<p>An exponentially-weighted moving average is then:</p>
<pre><code>estd x x&#39; = (\s ss -&gt; sqrt (ss - s**2)) &lt;$&gt; online id (*x) &lt;*&gt; online (*2) (*x&#39;)</code></pre>
<p>Note that, unlike the usual calc, the mean is conditional; itself a weighted average calculation, and with potentially a different decay function.</p>
<p>Just about any statistic can be made online. Here's an online, tuple correlation stat:</p>
<pre><code>cov r = (\xy xbar ybar -&gt; xy - xbar * ybar) &lt;$&gt; online (uncurry (*)) r &lt;*&gt; online fst r &lt;*&gt; online snd r
corr r = (\cov&#39; stdx stdy -&gt; cov&#39; / (stdx * stdy)) &lt;$&gt; cov r &lt;*&gt; L.premap fst (std r) &lt;*&gt; L.premap snd (std r)</code></pre>
<h2 id="cassava">cassava</h2>
<p>csv data arrives as a bytestring, gets decoded as a Vector, and decoding errors arrive as strings, so there's a fair bit of messiness working with Text Lists.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Csv</span>
<span class="kw">import </span><span class="dt">GHC.Base</span> (<span class="dt">String</span>)
<span class="kw">import </span><span class="dt">Data.Text</span> (pack)
<span class="kw">import </span><span class="dt">Data.Text.Encoding</span> (encodeUtf8Builder)
<span class="kw">import </span><span class="dt">Data.ByteString.Builder</span> (toLazyByteString)
<span class="kw">import </span><span class="dt">Data.Vector</span> (<span class="dt">Vector</span>)</code></pre></div>
<h2 id="pretty-printing">pretty printing</h2>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Formatting</span></code></pre></div>
<h2 id="chart-unit">chart-unit</h2>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Chart.Unit</span></code></pre></div>
<h2 id="data-munge">data munge</h2>
<p>data is from <a href="https://www.quandl.com/data/YAHOO/INDEX_GSPC-S-P-500-Index">yahoo</a> and consists of the following fields:</p>
<pre><code>Date,Open,High,Low,Close,Volume,Adjusted Close</code></pre>
<p>Stats are soley on adjusted close.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">YahooRep</span> <span class="fu">=</span> <span class="dt">YahooRep</span>
  {<span class="ot"> date ::</span> <span class="dt">ByteString</span>
  ,<span class="ot"> open ::</span> <span class="dt">ByteString</span>
  ,<span class="ot"> high ::</span> <span class="dt">ByteString</span>
  ,<span class="ot"> low ::</span> <span class="dt">ByteString</span>
  ,<span class="ot"> close ::</span> <span class="dt">ByteString</span>
  ,<span class="ot"> volume ::</span> <span class="dt">ByteString</span>
  ,<span class="ot"> adjustedClose ::</span> <span class="fu">!</span><span class="dt">Double</span>
  } <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">FromRecord</span> <span class="dt">YahooRep</span></code></pre></div>
<p>The base unit for analysis (which I've called ys to abstract) is log(1+return). Returns are geometric by nature, and this premap removes the effect before we get to distributions.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">ys ::</span> [<span class="dt">Double</span>]
ys <span class="fu">=</span> fmap (\x <span class="ot">-&gt;</span> log (<span class="dv">1</span><span class="fu">+</span>x)) <span class="fu">$</span> ret <span class="fu">$</span> reverse <span class="fu">$</span> unsafeInlineIO <span class="fu">$</span> <span class="kw">do</span>
    bs <span class="ot">&lt;-</span> readFile <span class="st">&quot;other/YAHOO-INDEX_GSPC.csv&quot;</span>
    <span class="kw">let</span> rawdata <span class="fu">=</span>
            decode <span class="dt">HasHeader</span> (toLazyByteString <span class="fu">$</span> encodeUtf8Builder bs)
<span class="ot">            ::</span> <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">Vector</span> <span class="dt">YahooRep</span>)
    <span class="kw">case</span> rawdata <span class="kw">of</span>
        (<span class="dt">Left</span> e) <span class="ot">-&gt;</span> panic <span class="fu">$</span> pack e
        (<span class="dt">Right</span> xs) <span class="ot">-&gt;</span> pure <span class="fu">$</span> adjustedClose <span class="fu">&lt;$&gt;</span> toList xs

<span class="ot">ret ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>]
ret [] <span class="fu">=</span> []
ret [_] <span class="fu">=</span> []
ret xs <span class="fu">=</span> L.fold diff&#39; xs
    <span class="kw">where</span>
        diff&#39; <span class="fu">=</span> <span class="dt">L.Fold</span> step ([], <span class="dt">Nothing</span>) fst
        step x a <span class="fu">=</span> <span class="kw">case</span> snd x <span class="kw">of</span>
            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> ([], <span class="dt">Just</span> a)
            <span class="dt">Just</span> a&#39; <span class="ot">-&gt;</span> ((a<span class="fu">-</span>a&#39;)<span class="fu">/</span>a&#39;<span class="fu">:</span>fst x, <span class="dt">Just</span> a)</code></pre></div>
<h2 id="main">main</h2>
<p>main constructs output into charts and markdown fragments which are stitched together in this file using pandoc.</p>
<pre><code>stack install &amp;&amp; readme &amp;&amp; pandoc -f markdown+lhs -t html -i readme.lhs -o readme.html --filter pandoc-include</code></pre>
<p>Think ipython notebook style without the fancy.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span></code></pre></div>
<p>The test data is the daily S&amp;P500 price index.</p>
<p>Time and money both tend towards being geometric, so a natural transformation is to look at the differences in log price as the main unit of analysis. This is also the log(1+return).</p>
<p>To abstract a bit, I'm going to name them ys. The xs in the data is time, but I'm choosing to forget this data piece and just retain the ordering information. So xs can be thought of as [0..] in most cases.</p>
<p>This also makes the ys additive so that sum(ys) is always and meaningfully log(1+return) over the range being summed.</p>
<p>The first 2k ys:</p>
<div class="figure">
<img src="other/elems.svg" />

</div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    fileSvg <span class="st">&quot;other/elems.svg&quot;</span> (<span class="dv">300</span>,<span class="dv">300</span>)
        (barRange
         (barChart <span class="fu">.</span> chartAxes <span class="fu">.</span> element <span class="dv">0</span> <span class="fu">.</span> axisTickStyle <span class="fu">.~</span> <span class="dt">TickNone</span> <span class="fu">$</span> def)
         (zip [<span class="dv">0</span><span class="fu">..</span>] (take <span class="dv">2000</span> ys)))
    fileSvg
        <span class="st">&quot;other/asum.svg&quot;</span> (<span class="dv">300</span>,<span class="dv">300</span>)
        (lineXY
         (lineChart <span class="fu">.</span> chartAxes <span class="fu">.~</span>
          fmap (axisTickStyle <span class="fu">.~</span> <span class="dt">TickNone</span>)
           (def <span class="fu">^.</span> chartAxes) <span class="fu">$</span> def)
         (zip [<span class="dv">0</span><span class="fu">..</span>] (L.scan L.sum ys)))</code></pre></div>
<p>Accumulated sum of ys aka <code>L.scan L.sum ys</code>:</p>
<div class="figure">
<img src="other/asum.svg" />

</div>
<h2 id="basic-stats">basic stats</h2>
<p>online mean and std at a 0.99 decay rate:</p>
<div class="figure">
<img src="other/moments.svg" />

</div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    <span class="kw">let</span> st <span class="fu">=</span> drop <span class="dv">1</span> <span class="fu">$</span> L.scan ((,) <span class="fu">&lt;$&gt;</span> (ma <span class="fl">0.9</span>) <span class="fu">&lt;*&gt;</span> (std <span class="fl">0.99</span>)) ys
    fileSvg <span class="st">&quot;other/moments.svg&quot;</span> (<span class="dv">300</span>,<span class="dv">300</span>) <span class="fu">$</span> (linesXY def <span class="fu">$</span>
        [ zip [<span class="dv">0</span><span class="fu">..</span>] (fst <span class="fu">&lt;$&gt;</span> st)
        , zip [<span class="dv">0</span><span class="fu">..</span>] (snd <span class="fu">&lt;$&gt;</span> st)
        ])</code></pre></div>
<h2 id="histogram">histogram</h2>
<p>A histogram of all elements, outliers truncated.</p>
<div class="figure">
<img src="other/hist.svg" />

</div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    <span class="kw">let</span> h <span class="fu">=</span> toXY <span class="fu">$</span> fill (rangeCuts <span class="dv">100</span> (<span class="fu">-</span><span class="fl">0.02</span>) <span class="fl">0.02</span>) ys
    fileSvg <span class="st">&quot;other/hist.svg&quot;</span> (<span class="dv">300</span>,<span class="dv">300</span>) <span class="fu">$</span>
      barRange
      (barChart <span class="fu">.</span> chartAxes <span class="fu">.~</span>
       [axisTickStyle <span class="fu">.~</span> <span class="dt">TickLabels</span>
        (sformat (prec <span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> rangeCuts <span class="dv">4</span> (<span class="fu">-</span><span class="fl">0.02</span>) <span class="fl">0.02</span>)
        <span class="fu">$</span> def] <span class="fu">$</span> def)
      h</code></pre></div>
<h2 id="quantiles">quantiles</h2>
<p>One problem with a histogram is the necessity of a prior about binning range and size. An online approach - enforcing a single step through the data starting from scratch - tends to push these two-pass problems to the surface.</p>
<p>A similar statistic is a quantile computation, where bin ranges are allowed to vary, with bin edges converging to quantiles (or percentiles or whatever). The decay method is to shrink the cuts towards the latest value.</p>
<pre><code>[min, 10th, 20th, .. 90th, max]: -0.229 -0.00741 -0.00603 -0.00292 -0.00110 0.000469 0.00203 0.00388 0.00667 0.00854 0.110
online [min, 10th, 20th, .. 90th, max] with decay rate = 0.996 (one year) -0.0339 -0.00504 -0.00175 -0.000316 0.000465 0.000828 0.00137 0.00238 0.00391 0.00677 0.0133</code></pre>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    writeFile <span class="st">&quot;other/quantiles.md&quot;</span> <span class="fu">$</span>
        <span class="st">&quot;\n    [min, 10th, 20th, .. 90th, max]:&quot;</span> <span class="fu">&lt;&gt;</span>
        mconcat (sformat (<span class="st">&quot; &quot;</span> <span class="fu">%</span> prec <span class="dv">3</span>) <span class="fu">&lt;$&gt;</span> toList
                 (L.fold (quantiles&#39; <span class="dv">11</span>) ys)) <span class="fu">&lt;&gt;</span>
        <span class="st">&quot;\n    online [min, 10th, 20th, .. 90th, max] with decay rate = 0.996 (one year)&quot;</span> <span class="fu">&lt;&gt;</span>
        mconcat (sformat (<span class="st">&quot; &quot;</span> <span class="fu">%</span> prec <span class="dv">3</span>) <span class="fu">&lt;$&gt;</span> toList
                 (L.fold (quantiles <span class="dv">11</span> identity <span class="fl">0.996</span>) ys))</code></pre></div>
<h2 id="digitize">digitize</h2>
<p>A related computation is to output the quantile of each value:</p>
<pre><code>first 100 values digitized into quantiles: 0.00 0.00 1.00 1.00 1.00 3.00 2.00 2.00 2.00 2.00 2.00 2.00 2.00 1.00 1.00 2.00 3.00 3.00 3.00 2.00 3.00 2.00 1.00 3.00 2.00 4.00 4.00 1.00 3.00 1.00 2.00 1.00 4.00 1.00 2.00 1.00 4.00 3.00 3.00 2.00 1.00 1.00 4.00 2.00 1.00 3.00 3.00 2.00 3.00 2.00 3.00 3.00 4.00 2.00 2.00 4.00 4.00 2.00 3.00 1.00 4.00 1.00 2.00 4.00 2.00 3.00 4.00 2.00 2.00 1.00 2.00 3.00 3.00 4.00 4.00 2.00 2.00 4.00 2.00 3.00 1.00 3.00 3.00 3.00 3.00 4.00 1.00 1.00 4.00 3.00 1.00 4.00 2.00 1.00 4.00 4.00 4.00 1.00 2.00 2.00</code></pre>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    writeFile <span class="st">&quot;other/digitize.md&quot;</span> <span class="fu">$</span>
        <span class="st">&quot;\n    first 100 values digitized into quantiles:&quot;</span> <span class="fu">&lt;&gt;</span>
        mconcat ((sformat (<span class="st">&quot; &quot;</span> <span class="fu">%</span> prec <span class="dv">3</span>) <span class="fu">&lt;$&gt;</span>)
                 (take <span class="dv">100</span> <span class="fu">$</span> L.scan (digitize <span class="dv">5</span> identity <span class="fl">0.996</span>) ys))

    filePng <span class="st">&quot;other/scratchpad.png&quot;</span> (<span class="dv">400</span>,<span class="dv">400</span>) <span class="fu">$</span> linesXY def
        [zip [<span class="dv">0</span><span class="fu">..</span>] (L.scan L.sum ys), zip [<span class="dv">0</span><span class="fu">..</span>] ((<span class="dv">2</span><span class="fu">*</span>)<span class="fu">&lt;$&gt;</span>(L.scan L.sum ys))]</code></pre></div>
<h2 id="workflow">workflow</h2>
<pre><code>stack install &amp;&amp; readme &amp;&amp; pandoc -f markdown+lhs -t html -i readme.lhs -o index.html --filter pandoc-include</code></pre>
